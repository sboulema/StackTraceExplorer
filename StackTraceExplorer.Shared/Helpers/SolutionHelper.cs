using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

namespace StackTraceExplorer.Helpers
{
    public static class SolutionHelper
    {
        public static Solution Solution { get; set; }
        public static ImmutableArray<Compilation> Compilations { get; set; }

        public static async Task<ImmutableArray<Compilation>> GetCompilationsAsync(Solution solution)
        {
            var compilationTasks = new Task<Compilation>[solution.ProjectIds.Count];
            for (var i = 0; i < compilationTasks.Length; i++)
            {
                var project = solution.GetProject(solution.ProjectIds[i]);
                compilationTasks[i] = project.GetCompilationAsync();
            }

            _ = await Task.WhenAll(compilationTasks);

            Compilations = compilationTasks.Select(t => t.Result).ToImmutableArray();
            return Compilations;
        }

        public static bool CompilationServiceNotInitialized => Compilations.IsDefault;

        public static ISymbol Resolve(string memberName)
        {
            ISymbol symbol = Compilations.Select(c => Resolve(c, memberName)).FirstOrDefault(s => s != null);
            return symbol;
        }

        public static ISymbol Resolve(Compilation compilation, string methodName)
        {
            var parts = methodName.Replace(".ctor", "#ctor").Split('.');

            var currentContainer = (INamespaceOrTypeSymbol)compilation.Assembly.Modules.Single().GlobalNamespace;

            for (var i = 0; currentContainer != null && i < parts.Length - 1; i++)
            {
                ParseTypeName(parts[i], out var typeOrNamespaceName, out var typeArity);
                if (string.IsNullOrEmpty(typeOrNamespaceName) && IsCompilerGeneratedName(parts[i]))
                {
                    // We could be dealing with a name like "SolutionHelperTests.<>c.<CreateSomeStackTraces>b__6_5()". On the member "<>c" we need to
                    // skip to the next part in order to find a member with the name, such as 'CreateSomeStackTraces" from the example above.
                    continue;
                }

                currentContainer = currentContainer
                    .GetMembers(typeOrNamespaceName)
                    .Where(n => typeArity == 0 || (n is INamedTypeSymbol t && t.Arity == typeArity))
                    .FirstOrDefault() as INamespaceOrTypeSymbol;
            }

            if (currentContainer == null)
            {
                return null;
            }

            string lastPart = parts.Last();
            var name = GetMemberName(lastPart);
            var members = currentContainer.GetMembers(name);

            if (!members.Any())
            {
                return null;
            }

            int methodArity = GetMethodArity(lastPart);
            IReadOnlyList<string> parameterTypes = GetMethodParameterTypes(lastPart);
            bool isCompilerGenerated = IsCompilerGeneratedName(lastPart);

            foreach (ISymbol member in members)
            {
                switch (member.Kind)
                {
                    case SymbolKind.Method:
                        if (member is IMethodSymbol method)
                        {
                            // isCompilerGenerated allows for "<CreateSomeStackTraces>b__7(String s)" to match "CreateSomeStackTraces" which
                            // might have a different number of parameters than what is found here.
                            if (IsMatch(method, parameterTypes, methodArity) || isCompilerGenerated)
                            {
                                return method;
                            }
                        }

                        break;
                    case SymbolKind.NamedType:
                        ParseTypeName(lastPart, out _, out int typeArity);
                        if (member is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.Arity == typeArity)
                        {
                            return member;
                        }
                        break;
                    default:
                        return member;
                }
            }

            return null;
        }

        /// <summary>
        /// Determine if the name is generated by the compiler. Examples include iterators, closures, anonymous methods, lambdas
        /// examples: 
        /// Types: "<>c", "<>c__DisplayClass", and so on "<>c__DisplayClass5_0`2"
        /// Methods: "<CreateSomeStackTraces>b__6_5()", "<GetSteps>b__2_1(IAsyncResult r)"
        /// </summary>
        static bool IsCompilerGeneratedName(string memberName)
        {
            return memberName.StartsWith("<", StringComparison.OrdinalIgnoreCase);
        }

        private static void ParseTypeName(string typeName, out string name, out int arity)
        {
            name = typeName;
            arity = 0;

            var backtick = typeName.IndexOf('`');
            int angleBracketOpen = typeName.IndexOf('<');
            if (angleBracketOpen >= 0)
            {
                int angleBracketClose = typeName.IndexOf('>', angleBracketOpen);
                if (angleBracketClose > 0)
                {
                    name = typeName.Substring(angleBracketOpen + 1, angleBracketClose - angleBracketOpen - 1);
                }
            }

            if (backtick >= 0)
            {
                name = typeName.Substring(0, backtick);
                var arityText = typeName.Substring(backtick + 1);
                arity = int.Parse(arityText);
            }
        }

        public static string GetMemberName(string memberNameAndSignature)
        {
            string result = memberNameAndSignature;
            if (IsCompilerGeneratedName(memberNameAndSignature))
            {
                // This could be an anonymous method name like "<CreateSomeStackTraces>b__6_5()", in that case
                // return "CreateSomeStackTraces"
                result = memberNameAndSignature.Split(new[] { '<', '>' }, StringSplitOptions.RemoveEmptyEntries)[0];
            }
            else
            {
                int firstSeparator = memberNameAndSignature.IndexOfAny(new[] { '(', '[', '`' });
                if (firstSeparator != -1)
                {
                    result = memberNameAndSignature.Substring(0, firstSeparator);
                }

                if (result == "#ctor")
                {
                    result = ".ctor";
                }
            }

            return result;
        }

        private static int GetMethodArity(string methodNameAndSignature)
        {
            var parenthesis = methodNameAndSignature.IndexOf('(');
            if (parenthesis < 0)
            {
                return 0;
            }

            var openBracket = methodNameAndSignature.IndexOf('[', 0, parenthesis);
            if (openBracket < 0)
            {
                return 0;
            }

            var closeBracket = methodNameAndSignature.IndexOf(']', 0, parenthesis);
            if (closeBracket < 0)
            {
                return 0;
            }

            var result = 1;
            for (var i = openBracket; i <= closeBracket; i++)
            {
                if (methodNameAndSignature[i] == ',')
                {
                    result++;
                }
            }

            return result;
        }

        private static IReadOnlyList<string> GetMethodParameterTypes(string methodNameAndSignature)
        {
            var openParenthesis = methodNameAndSignature.IndexOf('(');
            if (openParenthesis < 0)
            {
                return Array.Empty<string>();
            }

            var closeParenthesis = methodNameAndSignature.IndexOf(')');
            var signatureStart = openParenthesis + 1;
            var signatureLength = closeParenthesis - signatureStart;
            var signature = methodNameAndSignature.Substring(signatureStart, signatureLength);
            var parameters = signature.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            for (var i = 0; i < parameters.Length; i++)
            {
                parameters[i] = parameters[i].Trim();
            }

            var result = new List<string>(parameters.Length);

            foreach (var parameter in parameters)
            {
                var space = parameter.IndexOf(' ');
                var typeName = parameter.Substring(0, space);
                result.Add(typeName);
            }

            return result;
        }

        private static bool IsMatch(IMethodSymbol method, IReadOnlyList<string> parameterTypes, int methodArity)
        {
            if (method.Arity != methodArity || method.Parameters.Length != parameterTypes.Count)
            {
                return false;
            }

            for (var i = 0; i < method.Parameters.Length; i++)
            {
                var symbolTypeName = GetTypeName(method.Parameters[i]);
                var frameTypename = parameterTypes[i];

                if (symbolTypeName != frameTypename)
                {
                    return false;
                }
            }

            return true;
        }

        private static string GetTypeName(IParameterSymbol symbol)
        {
            var sb = new StringBuilder();

            if (symbol.Type is IArrayTypeSymbol array)
            {
                sb.Append(array.ElementType.MetadataName);
                sb.Append("[]");
            }
            else if (symbol.Type is IPointerTypeSymbol pointer)
            {
                sb.Append(pointer.PointedAtType.MetadataName);
                sb.Append('*');
            }
            else
            {
                sb.Append(symbol.Type.MetadataName);
            }

            if (symbol.RefKind != RefKind.None)
            {
                sb.Append("&");
            }

            return sb.ToString();
        }
    }
}